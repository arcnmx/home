{ config, lib, pkgs, ... }:

with lib;

let

  cfg = config.programs.firefox;

  extensionPath = "extensions/{ec8030f7-c20a-464f-9b0e-13a3a9e97384}";

  profiles =
    flip mapAttrs' cfg.profiles (_: profile:
      nameValuePair "Profile${toString profile.id}" {
        Name = profile.name;
        Path = profile.path;
        IsRelative = 1;
        Default = if profile.isDefault then 1 else 0;
      }
    ) // {
      General = {
        StartWithLastProfile = 1;
      };
    };

  profilesIni = generators.toINI {} profiles;

  mkUserJs = prefs: extraPrefs: ''
    // Generated by Home Manager.

    ${concatStrings (mapAttrsToList (name: value: ''
      user_pref("${name}", ${builtins.toJSON value});
    '') prefs)}

    ${extraPrefs}
  '';

    browserName = cfg.package.browserName
      or (builtins.parseDrvName cfg.package.name).name;

    fcfg = setAttrByPath [browserName] {
      enableAdobeFlash = cfg.enableAdobeFlash;
      enableGoogleTalkPlugin = cfg.enableGoogleTalk;
      icedtea = cfg.enableIcedTea;
    };

    wrapper = pkgs.wrapFirefox.override {
      config = fcfg;
    };

in

{
  meta.maintainers = [ maintainers.rycee ];

  options = {
    programs.firefox = {
      enable = mkEnableOption "Firefox";

      package = mkOption {
        type = types.package;
        default = pkgs.firefox-unwrapped;
        defaultText = "pkgs.firefox-unwrapped";
        description = "The unwrapped Firefox package to use.";
      };

      packageWrapped = mkOption {
        type = types.package;
        default = wrapper cfg.package cfg.wrapperConfig;
        defaultText = "pkgs.wrapFirefox package wrapperConfig";
        description = "The wrapped Firefox package.";
      };

      wrapperConfig = mkOption {
        type = types.attrsOf types.unspecified;
        default = { };
        description = "Extra arguments to pass to the firefox wrapper.";
        example = literalExample ''
          {
            extraNativeMessagingHosts = [
              pkgs.tridactyl-native
            ];
          }
        '';
      };
      # TODO: option that symlinks ${firefoxWrapped}/lib/mozilla/native-messaging-hosts to ~/.mozilla/native-messaging-hosts for the firefox binary overlay release

      extensions = mkOption {
        type = types.listOf types.package;
        default = [];
        example = literalExample ''
          with pkgs.nur.repos.rycee.firefox-addons; [
            https-everywhere
            privacy-badger
          ]
        '';
        description = ''
          List of Firefox add-on packages to install. Note, it is
          necessary to manually enable these extensions inside Firefox
          after the first installation.
        '';
      };

      profiles = mkOption {
        type = types.attrsOf (types.submodule ({config, name, ...}: {
          options = {
            name = mkOption {
              type = types.str;
              default = name;
              description = "Profile name.";
            };

            id = mkOption {
              type = types.ints.unsigned;
              default = 0;
              description = ''
                Profile ID. This should be set to a unique number per profile.
              '';
            };

            settings = mkOption {
              type = with types; attrsOf (either bool (either int str));
              default = {};
              example = literalExample ''
                {
                  "browser.startup.homepage" = "https://nixos.org";
                  "browser.search.region" = "GB";
                  "browser.search.isUS" = false;
                  "distribution.searchplugins.defaultLocale" = "en-GB";
                  "general.useragent.locale" = "en-GB";
                  "browser.bookmarks.showMobileBookmarks" = true;
                }
              '';
              description = "Attribute set of Firefox preferences.";
            };

            extraConfig = mkOption {
              type = types.lines;
              default = "";
              description = ''
                Extra preferences to add to <filename>user.js</filename>.
              '';
            };

            userChrome = mkOption {
              type = types.lines;
              default = "";
              description = "Custom Firefox CSS.";
              example = ''
                /* Hide tab bar in FF Quantum */
                @-moz-document url("chrome://browser/content/browser.xul") {
                  #TabsToolbar {
                    visibility: collapse !important;
                    margin-bottom: 21px !important;
                  }

                  #sidebar-box[sidebarcommand="treestyletab_piro_sakura_ne_jp-sidebar-action"] #sidebar-header {
                    visibility: collapse !important;
                  }
                }
              '';
            };

            userChromeBindings = mkOption {
              type = types.listOf types.str;
              description = "Custom Firefox XUL bindings";
              default = [ ];
              example = [
                ''
                  <binding id="attachment-listcol">
                    <implementation>
                      <constructor><![CDATA[
                        this.removeAttribute("flex")
                      ]]></constructor>
                    </implementation>
                  </binding>
                ''
              ];
            };

            path = mkOption {
              type = types.str;
              default = name;
              description = "Profile path.";
            };

            isDefault = mkOption {
              type = types.bool;
              default = config.id == 0;
              defaultText = "true if profile ID is 0";
              description = "Whether this is a default profile.";
            };

            containers = mkOption {
              default = { };
              description = "Firefox multi-account container definitions";
              type = types.submodule ({ ... }: {
                options = {
                  identities = mkOption {
                    description = "Ordered container identity list";
                    default = [ ];
                    example = [
                      { id = 5; name = "Shopping"; icon = "gift"; color = "turquoise"; }
                    ];
                    type = types.listOf (types.submodule ({ ... }: {
                      options = {
                        id = mkOption {
                          description = "User Context ID";
                          type = types.ints.unsigned;
                        };
                        name = mkOption {
                          description = "Container name";
                          type = types.str;
                        };
                        icon = mkOption {
                          description = "Icon";
                          type = types.enum [
                            "" "fingerprint" "briefcase" "dollar" "cart" "circle" "gift"
                            "vacation" "food" "fruit" "pet" "tree" "chill" "fence"
                          ];
                          default = "circle";
                        };
                        color = mkOption {
                          description = "Color";
                          type = types.enum [
                            "" "toolbar" # what kind of name for black is this???
                            "blue" "turquoise" "green" "yellow" "red" "pink" "purple" "orange"
                          ];
                          default = "toolbar";
                        };
                        public = mkOption {
                          description = "Whether the container is visible or not";
                          type = types.bool;
                          default = true;
                        };
                      };
                    }));
                  };
                };
              });
            };
          };

          config = {
            settings = optionalAttrs (config.containers.identities != []) {
              "privacy.userContext.enabled" = mkDefault true;
              "privacy.userContext.ui.enabled" = mkDefault true;
            } // optionalAttrs (config.userChrome != "" || config.userChromeBindings != []) {
              "toolkit.legacyUserProfileCustomizations.stylesheets" = mkDefault true;
            };
          };
        }));
        default = {};
        description = "Attribute set of Firefox profiles.";
      };

      enableAdobeFlash = mkOption {
        type = types.bool;
        default = false;
        description = "Whether to enable the unfree Adobe Flash plugin.";
      };

      enableGoogleTalk = mkOption {
        type = types.bool;
        default = false;
        description = ''
          Whether to enable the unfree Google Talk plugin. This option
          is <emphasis>deprecated</emphasis> and will only work if

          <programlisting language="nix">
          programs.firefox.package = pkgs.firefox-esr-52-unwrapped;
          </programlisting>

          and the <option>plugin.load_flash_only</option> Firefox
          option has been disabled.
        '';
      };

      enableIcedTea = mkOption {
        type = types.bool;
        default = false;
        description = ''
          Whether to enable the Java applet plugin. This option is
          <emphasis>deprecated</emphasis> and will only work if

          <programlisting language="nix">
          programs.firefox.package = pkgs.firefox-esr-52-unwrapped;
          </programlisting>

          and the <option>plugin.load_flash_only</option> Firefox
          option has been disabled.
        '';
      };
    };
  };

  config = mkIf cfg.enable {
    assertions = [
      (
        let
          defaults =
            catAttrs "name" (filter (a: a.isDefault) (attrValues cfg.profiles));
        in {
          assertion = cfg.profiles == {} || length defaults == 1;
          message =
            "Must have exactly one default Firefox profile but found "
            + toString (length defaults)
            + optionalString (length defaults > 1)
                (", namely " + concatStringsSep ", " defaults);
        }
      )

      (
        let
          duplicates =
            filterAttrs (_: v: length v != 1)
            (zipAttrs
            (mapAttrsToList (n: v: { "${toString v.id}" = n; })
            (cfg.profiles)));

          mkMsg = n: v: "  - ID ${n} is used by ${concatStringsSep ", " v}";
        in {
          assertion = duplicates == {};
          message =
            "Must not have Firefox profiles with duplicate IDs but\n"
            + concatStringsSep "\n" (mapAttrsToList mkMsg duplicates);
        }
      )
    ];

    home.packages = [ cfg.packageWrapped ];

    home.file = mkMerge (
      [{
        ".mozilla/${extensionPath}" = mkIf (cfg.extensions != []) (
          let
            extensionsEnv = pkgs.buildEnv {
              name = "hm-firefox-extensions";
              paths = cfg.extensions;
            };
          in {
            source = "${extensionsEnv}/share/mozilla/${extensionPath}";
            recursive = true;
          }
        );

        ".mozilla/firefox/profiles.ini" = mkIf (cfg.profiles != {}) {
          text = profilesIni;
        };
      }]
      ++ flip mapAttrsToList cfg.profiles (_: profile: {
        ".mozilla/firefox/${profile.path}/chrome/userChrome.css" =
          mkIf (profile.userChrome != "") {
            text = profile.userChrome;
          };

        ".mozilla/firefox/${profile.path}/chrome/userChrome.xml" =
          mkIf (profile.userChromeBindings != []) {
            text = ''
              <?xml version="1.0"?>
              <bindings xmlns="http://www.mozilla.org/xbl"
               xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
                ${concatStringsSep "\n" profile.userChromeBindings}
              </bindings>
            '';
          };

        ".mozilla/firefox/${profile.path}/user.js" =
          mkIf (profile.settings != {} || profile.extraConfig != "") {
            text = mkUserJs profile.settings profile.extraConfig;
          };

        ".mozilla/firefox/${profile.path}/containers.json" = mkIf (profile.containers.identities != []) {
          text = builtins.toJSON {
            version = 4;
            lastUserContextId = foldl max 0 (map ({ id, ... }: id) profile.containers.identities);
            identities = map (c: {
              inherit (c) name icon color public;
              userContextId = c.id;
            }) profile.containers.identities ++ [{
              userContextId = 4294967295;
              name = "userContextIdInternal.webextStorageLocal";
              icon = "";
              color = "";
              public = false;
              accessKey = "";
            }];
          };
        };
      })
    );
  };
}
